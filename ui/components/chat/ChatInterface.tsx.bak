'use client';

import { useState, useEffect, useRef, useMemo } from 'react';
import { useSession } from 'next-auth/react';
import { chatApi, ChatRequest, ChatResponse } from '@/lib/api/kevin';
import { ChatMessage } from '@/models/ChatSession';
import { useRouter } from 'next/navigation';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { generateContextSummary } from '@/lib/utils/contextSummary';

// Types for streaming events
interface ThinkingStep {
  type: string;
  description: string;
  time: string;
  duration_ms?: number;
  content?: string;
}

interface StreamEvent {
  event: string;
  data: any;
}

interface ChatInterfaceProps {
  sessionId?: string;
  onNewSession?: (sessionId: string) => void;
  initialMessages?: ChatMessage[];
}

// Debug logger function for thinking steps
const logThinkingStep = (prefix: string, step: ThinkingStep | null, eventData?: string) => {
  console.log(
    `%c${prefix}`,
    'background: #0066cc; color: white; padding: 2px 5px; border-radius: 3px; font-weight: bold;',
    step 
      ? {
          description: step.description,
          time: step.time,
          duration: step.duration_ms,
          contentLength: step.content?.length || 0
        }
      : 'No step data',
    eventData ? `Raw data: ${eventData.substring(0, 100)}${eventData.length > 100 ? '...' : ''}` : ''
  );
};

export default function ChatInterface({ 
  sessionId, 
  onNewSession,
  initialMessages = [] 
}: ChatInterfaceProps) {
  const { data: session } = useSession();
  const [messages, setMessages] = useState<ChatMessage[]>(initialMessages);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [conversationId, setConversationId] = useState<string | undefined>(sessionId);
  const [isThinking, setIsThinking] = useState(false);
  const [thinkingSteps, setThinkingSteps] = useState<ThinkingStep[]>([]);
  const [streamingMessage, setStreamingMessage] = useState('');
  const [streamingId, setStreamingId] = useState<string | null>(null);
  const [isSearchMode, setIsSearchMode] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  // Track the last saved state to prevent duplicate saves
  const [lastSavedHash, setLastSavedHash] = useState<string>('');
  const [contextSummary, setContextSummary] = useState<string>('');
  
  // Use a ref to keep track of the accumulated message content
  // This is more reliable than relying only on state for capturing content
  const accumulatedContentRef = useRef('');
  
  const eventSourceRef = useRef<EventSource | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const chatContainerRef = useRef<HTMLDivElement>(null);
  const router = useRouter();

  // Group messages into exchanges (user + assistant pairs)
  const messageExchanges = useMemo(() => {
    const exchanges: ChatMessage[][] = [];
    let currentExchange: ChatMessage[] = [];
    
    messages.forEach(message => {
      currentExchange.push(message);
      if (message.role === 'assistant') {
        exchanges.push([...currentExchange]);
        currentExchange = [];
      }
    });
    
    // Add any remaining messages
    if (currentExchange.length > 0) {
      exchanges.push(currentExchange);
    }
    
    return exchanges;
  }, [messages]);

  // Log component initialization
  useEffect(() => {
    console.log('ChatInterface mounted/initialized', 
      { initialMessagesCount: initialMessages.length, sessionId });
  }, []);

  // Scroll to bottom when new messages are added
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
    
    // Add debug logging to track state changes
    console.log('State updated - Messages:', messages.length, 'Streaming:', streamingMessage ? 'yes' : 'no');
  }, [messages, streamingMessage, thinkingSteps]);

  // Clean up event source on unmount
  useEffect(() => {
    return () => {
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }
    };
  }, []);

  // Generate a hash of the current messages to track if they've been saved
  const generateMessageHash = (msgs: ChatMessage[]): string => {
    return msgs.map(m => `${m.role}:${m.content.substring(0, 50)}`).join('|');
  };

  // Update context summary when messages change
  useEffect(() => {
    if (messages.length > 0) {
      const summary = generateContextSummary(messages);
      setContextSummary(summary);
    }
  }, [messages]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!input.trim() || isLoading) return;
    
    // Add user message to the UI
    const userMessage: ChatMessage = {
      role: 'user',
      content: input,
      timestamp: new Date()
    };
    
    setMessages(prev => [...prev, userMessage]);
    setIsLoading(true);
    setInput('');
    
    // If in search mode, add search prefix
    if (isSearchMode) {
      await streamResponse(`[Search] ${input}`);
      setIsSearchMode(false); // Reset search mode after sending
    } else {
      // Regular chat mode
      await streamResponse(input);
    }
  };

  const streamResponse = async (query: string) => {
    // Close any existing event source
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
    }
    
    // Reset all state for new response
    setIsThinking(true); // Always set thinking to true when we start a response
    setThinkingSteps([]);
    setStreamingMessage('');
    setIsLoading(true);
    
    // Reset the accumulated content ref
    accumulatedContentRef.current = '';
    
    // Create request for Kevin API
    const chatRequest: ChatRequest = {
      query,
      conversation_id: conversationId,
      context_summary: contextSummary,
      stream: true,
      debug_mode: true // Enable debug mode to get thinking steps
    };
    
    console.log('Sending chat request with debug_mode enabled:', chatRequest);
    
    // Get streaming URL
    const streamUrl = chatApi.getStreamUrl(chatRequest);
    console.log('Stream URL:', streamUrl);
    
    // Create synthetic thinking step immediately
    const initialStep = {
      type: 'thinking',
      description: 'Starting request to DeepSeek r1',
      time: new Date().toTimeString().split(' ')[0],
      duration_ms: 0
    };
    setThinkingSteps([initialStep]);
    
    // Create new event source with debug timing
    console.log(`Creating EventSource at ${new Date().toISOString()}`);
    const eventSource = new EventSource(streamUrl);
    eventSourceRef.current = eventSource;
    
    // Add performance timing
    const streamStartTime = Date.now();
    
    // Setup progressive synthetic thinking steps with constant reference for cleanup
    const syntheticSteps = [
      'Starting query processing',
      'Analyzing query context',
      'Processing with DeepSeek r1',
      'Reasoning through the question',
      'Formulating response',
      'Organizing content',
      'Finalizing answer'
    ];

    // Add first synthetic step immediately after connection establishes
    setTimeout(() => {
      console.log('Adding first synthetic step');
      if (isThinking) {
        const newStep = {
          type: 'thinking',
          description: syntheticSteps[0],
          time: new Date().toTimeString().split(' ')[0],
          duration_ms: 500
        };
        setThinkingSteps(prev => {
          // Check if we already have this step
          const hasStep = prev.some(step => step.description === newStep.description);
          if (hasStep) {
            console.log('Step already exists, not adding duplicate:', newStep.description);
            return prev;
          }
          console.log('Adding synthetic step:', newStep.description);
          return [...prev, newStep];
        });
      }
    }, 500);
    
    // Add remaining synthetic steps at intervals
    let stepCount = 1; // Start with the second step (index 1)
    const syntheticStepsInterval = setInterval(() => {
      console.log('Synthetic steps interval fired, step:', stepCount);
      
      if (stepCount < syntheticSteps.length && isThinking) {
        const newStep = {
          type: 'thinking',
          description: syntheticSteps[stepCount],
          time: new Date().toTimeString().split(' ')[0],
          duration_ms: (stepCount + 1) * 500
        };
        
        setThinkingSteps(prev => {
          // Check if we already have this step
          const hasStep = prev.some(step => step.description === newStep.description);
          if (hasStep) {
            console.log('Step already exists, not adding duplicate:', newStep.description);
            return prev;
          }
          console.log('Adding synthetic step:', newStep.description);
          return [...prev, newStep];
        });
        
        stepCount++;
      } else {
        console.log('Clearing synthetic steps interval');
        clearInterval(syntheticStepsInterval);
      }
    }, 2000); // 2 seconds between steps
    
    // Log connection state changes
    eventSource.onopen = () => {
      console.log(`EventSource connection opened at ${new Date().toISOString()} (${Date.now() - streamStartTime}ms after request)`);
    };
    
    // Set up event listeners with better debugging
    eventSource.addEventListener('thinking_start', (e) => {
      console.log(`Thinking START event received at ${new Date().toISOString()} (${Date.now() - streamStartTime}ms):`, e.data);
      handleThinkingStart(e);
    });
    
    eventSource.addEventListener('thinking_update', (e) => {
      console.log(`Thinking UPDATE event received at ${new Date().toISOString()} (${Date.now() - streamStartTime}ms):`, e.data);
      handleThinkingUpdate(e);
    });
    
    eventSource.addEventListener('thinking_end', (e) => {
      console.log(`Thinking END event received at ${new Date().toISOString()} (${Date.now() - streamStartTime}ms):`, e.data);
      handleThinkingEnd(e);
    });
    
    eventSource.addEventListener('answer_start', (e) => {
      console.log(`Answer START event received at ${new Date().toISOString()} (${Date.now() - streamStartTime}ms)`);
      handleAnswerStart();
    });
    
    eventSource.addEventListener('answer_chunk', (e) => {
      console.log(`Answer CHUNK event received at ${new Date().toISOString()} (${Date.now() - streamStartTime}ms)`);
      handleAnswerChunk(e as MessageEvent);
    });
    
    // Add handler for the plain 'answer' event to handle full answers (e.g., from cache)
    eventSource.addEventListener('answer', (e) => {
      console.log(`Answer event received at ${new Date().toISOString()} (${Date.now() - streamStartTime}ms)`);
      handleAnswer(e as MessageEvent);
    });
    
    eventSource.addEventListener('document', (e) => {
      console.log(`Document event received at ${new Date().toISOString()} (${Date.now() - streamStartTime}ms)`);
      handleDocument(e as MessageEvent);
    });
    
    eventSource.addEventListener('done', (e) => {
      console.log(`Done event received at ${new Date().toISOString()} (${Date.now() - streamStartTime}ms)`);
      handleDone(e as MessageEvent);
    });
    
    eventSource.addEventListener('error', (e) => {
      console.log(`Error event received at ${new Date().toISOString()} (${Date.now() - streamStartTime}ms)`);
      handleError(e as MessageEvent);
    });
    
    // Clean up function for synthetic steps when done
    const cleanup = () => {
      console.log('Cleaning up synthetic steps interval');
      clearInterval(syntheticStepsInterval);
    };
    
    // Handle errors
    eventSource.onerror = (error) => {
      console.log('EventSource connection error occurred:', error);
      eventSource.close();
      setIsLoading(false);
      setIsThinking(false);
      cleanup();
      
      // Add user-friendly error message to the chat
      const errorMessage: ChatMessage = {
        role: 'assistant',
        content: "I'm sorry, there was an error connecting to the chat service. Please try again later.",
        timestamp: new Date()
      };
      setMessages(prev => [...prev, errorMessage]);
    };
    
    // Return cleanup function
    return () => {
      cleanup();
    };
  };

  // Event handlers for streaming
  const handleThinkingStart = (e: MessageEvent) => {
    console.log('handleThinkingStart called with data:', e.data);
    setIsThinking(true);
    try {
      const data = JSON.parse(e.data);
      console.log('Thinking started:', data);
      logThinkingStep('THINKING START', data, e.data);
    } catch (err) {
      console.error('Error parsing thinking_start event', err);
    }
  };

  // Enhance handleThinkingUpdate to better debug and handle real thinking steps
  const handleThinkingUpdate = (e: MessageEvent) => {
    console.log('handleThinkingUpdate called with data:', e.data);
    try {
      const data = JSON.parse(e.data) as ThinkingStep;
      console.log('Thinking update parsed:', data);
      logThinkingStep('THINKING UPDATE', data, e.data);
      
      // Only add real steps that have unique descriptions
      if (data && data.description) {
        // Check if we already have this step (avoid duplicates)
        setThinkingSteps(prev => {
          const isDuplicate = prev.some(
            step => step.description === data.description
          );
          
          if (!isDuplicate) {
            console.log('Adding real thinking step:', data.description);
            return [...prev, data];
          } else {
            console.log('Skipping duplicate thinking step:', data.description);
            return prev;
          }
        });
      }
    } catch (err) {
      console.error('Error parsing thinking_update event', err, 'Raw data:', e.data);
    }
  };

  const handleThinkingEnd = (e: MessageEvent) => {
    console.log('handleThinkingEnd called with data:', e.data);
    // We don't set isThinking to false here anymore so steps remain visible
    // The state will be cleared after everything is complete in handleDone
    try {
      const data = JSON.parse(e.data);
      console.log('Thinking ended with data:', data);
      logThinkingStep('THINKING END', data, e.data);
      
      // Add a final thinking step when thinking ends
      const finalStep = {
        type: 'thinking',
        description: 'Thinking complete, generating response',
        time: new Date().toTimeString().split(' ')[0],
        duration_ms: 0
      };
      
      setThinkingSteps(prev => {
        // Check for duplicate
        const isDuplicate = prev.some(step => step.description === finalStep.description);
        if (!isDuplicate) {
          return [...prev, finalStep];
        }
        return prev;
      });
    } catch (err) {
      console.error('Error in thinking_end handler:', err);
    }
  };

  const handleAnswerStart = () => {
    console.log('handleAnswerStart called');
    // Generate a unique ID for this streaming session
    const newStreamingId = Date.now().toString();
    setStreamingId(newStreamingId);
    
    // Reset both the state and the ref
    setStreamingMessage('');
    accumulatedContentRef.current = '';
    
    // Add a thinking step for answer start
    const answerStartStep = {
      type: 'thinking',
      description: 'Starting to generate response',
      time: new Date().toTimeString().split(' ')[0],
      duration_ms: 0
    };
    
    setThinkingSteps(prev => {
      // Check for duplicate
      const isDuplicate = prev.some(step => step.description === answerStartStep.description);
      if (!isDuplicate) {
        return [...prev, answerStartStep];
      }
      return prev;
    });
  };

  const handleAnswerChunk = (e: MessageEvent) => {
    try {
      console.log(`Answer chunk received at ${new Date().toISOString()}`);
      const data = JSON.parse(e.data);
      
      // Get the chunk content
      const chunk = data.chunk || '';
      
      if (chunk && chunk.trim().length > 0) {
        console.log(`Received answer chunk (${chunk.length} chars)`);
        
        // Update the accumulated content
        accumulatedContentRef.current += chunk;
        
        // Update the UI immediately
        setStreamingMessage(accumulatedContentRef.current);
        
        // Ensure we scroll to bottom with each chunk
        setTimeout(() => {
          if (messagesEndRef.current) {
            messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
          }
        }, 0);
      } else {
        console.warn('Received empty chunk in answer_chunk event');
      }
    } catch (err) {
      console.error('Error parsing answer chunk event', err);
    }
  };

  // Handler for the full answer event
  const handleAnswer = (e: MessageEvent) => {
    try {
      console.log(`Answer event received at ${new Date().toISOString()}`);
      const data = JSON.parse(e.data) as { answer?: string };
      
      // If we somehow don't have an answer, log and return
      if (!data.answer) {
        console.warn('Answer event received but no answer field in data');
        return;
      }
      
      // Store the full answer for reference
      const fullAnswer = data.answer;
      console.log(`Full answer received, length: ${fullAnswer.length} characters`);
      
      // Only use the full answer if we don't already have accumulated content
      if (!accumulatedContentRef.current || accumulatedContentRef.current.trim().length === 0) {
        console.log('Using full answer from answer event since no accumulated content exists');
        
        // Set the accumulated content to the full answer
        accumulatedContentRef.current = fullAnswer;
        
        // Update UI with the full answer - immediately show the first portion
        // to ensure the user sees something right away
        const initialChunk = fullAnswer.slice(0, 100); // Show the first 100 chars immediately
        setStreamingMessage(initialChunk);
        
        // Schedule the remaining chunks to simulate streaming for a smoother experience
        simulateChunks(fullAnswer, initialChunk);
      } else {
        console.log('Ignoring full answer as we already have accumulated content:', 
          accumulatedContentRef.current.length);
        
        // If the accumulated content is shorter than the full answer, 
        // it might be incomplete - use the full answer instead
        if (accumulatedContentRef.current.length < fullAnswer.length) {
          console.warn('Accumulated content appears to be shorter than full answer, using full answer instead');
          accumulatedContentRef.current = fullAnswer;
          
          // Update UI with the full answer in chunks
          simulateChunks(fullAnswer, '');
        }
      }
    } catch (err) {
      console.error('Error parsing answer event', err);
    }
  };

  // Function to simulate chunked streaming for a better UX
  const simulateChunks = (fullText: string, initialChunk: string = '') => {
    // Use natural language boundaries for chunking where possible
    const sentenceEndPattern = /[.!?]\s+/g;
    const paragraphEndPattern = /\n\s*\n/g;
    
    // Find all sentence and paragraph boundaries in the text
    const sentenceBreaks: number[] = [];
    let match;
    
    // Find sentence breaks
    while ((match = sentenceEndPattern.exec(fullText)) !== null) {
      sentenceBreaks.push(match.index + match[0].length);
    }
    
    // Find paragraph breaks
    const paragraphBreaks: number[] = [];
    while ((match = paragraphEndPattern.exec(fullText)) !== null) {
      paragraphBreaks.push(match.index + match[0].length);
    }
    
    // Combine all breaks and sort
    const allBreaks = [...sentenceBreaks, ...paragraphBreaks].sort((a, b) => a - b);
    
    // Determine chunk size based on text length
    const baseChunkSize = Math.min(200, Math.max(50, Math.floor(fullText.length / 20)));
    
    // Create chunks at natural boundaries, but ensure they're not too large
    const chunks: string[] = [];
    let startPos = initialChunk.length; // Start after the initial chunk
    
    while (startPos < fullText.length) {
      // Find the next natural break within a reasonable range
      const targetEndPos = startPos + baseChunkSize;
      
      // Find the closest natural break to our target position
      const nextBreak = allBreaks.find(pos => pos > startPos && pos <= targetEndPos + 100);
      
      let endPos;
      if (nextBreak) {
        // We found a natural break within our target range (or a bit beyond)
        endPos = nextBreak;
      } else {
        // No natural break found, use a reasonable chunk size
        // But check if we're near a word boundary
        endPos = Math.min(targetEndPos, fullText.length);
        
        // Try to break at a word boundary if possible
        if (endPos < fullText.length) {
          const nextSpace = fullText.indexOf(' ', endPos);
          if (nextSpace > 0 && nextSpace - endPos < 20) { // If next space is close, use it
            endPos = nextSpace + 1;
          }
        }
      }
      
      // Extract the chunk
      const chunk = fullText.substring(startPos, endPos);
      chunks.push(chunk);
      
      // Move to next position
      startPos = endPos;
    }
    
    console.log(`Created ${chunks.length} chunks from full answer`);
    
    // Display chunks with natural timing
    let displayedContent = initialChunk;
    
    chunks.forEach((chunk, index) => {
      // Calculate delay based on chunk size
      // Larger chunks need more time to read
      const charsPerSecond = 30; // Adjust to change perceived "typing" speed
      const baseDelay = 100; // Minimum delay
      const delay = baseDelay + (chunk.length / charsPerSecond) * 1000;
      
      setTimeout(() => {
        // Add the next chunk
        displayedContent += chunk;
        setStreamingMessage(displayedContent);
        
        // If it's the last chunk, ensure our accumulated content has the full text
        if (index === chunks.length - 1) {
          accumulatedContentRef.current = fullText; // Ensure we have the complete text
        }
      }, index * delay);
    });
  };

  const handleDocument = (e: MessageEvent) => {
    try {
      const data = JSON.parse(e.data);
      console.log('Document:', data);
      // Handle documents as needed
    } catch (err) {
      console.error('Error parsing document event', err);
    }
  };

  const handleDone = (e: MessageEvent) => {
    try {
      console.log(`Done event received at ${new Date().toISOString()} - Starting message processing`);
      const data = JSON.parse(e.data);
      
      // Update conversation ID
      if (data.conversation_id) {
        setConversationId(data.conversation_id);
        
        // Notify parent about new session if needed
        if (!sessionId && onNewSession) {
          onNewSession(data.conversation_id);
        }
      }
      
      // Get the complete content from our ref
      const finalContent = accumulatedContentRef.current;
      console.log('Final content from ref length:', finalContent.length);

      // Check if content appears to be incomplete (ends with a sentence fragment)
      const contentComplete = finalContent && (
        finalContent.endsWith('.') || 
        finalContent.endsWith('?') || 
        finalContent.endsWith('!') || 
        finalContent.endsWith('"') || 
        finalContent.endsWith(')') || 
        finalContent.endsWith(']')
      );
      
      if (!contentComplete) {
        console.warn('Content appears to be incomplete (no ending punctuation). This may cause display issues.');
      }
      
      // Close the event source first
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
        eventSourceRef.current = null;
      }
      
      if (!finalContent || finalContent.trim().length === 0) {
        console.error('Empty message content detected, not adding to chat. Ref content:', 
          finalContent ? 'empty string' : 'null/undefined');
        setIsLoading(false);
        setIsThinking(false);
        return;
      }
      
      // Always make a local copy of the final content to avoid race conditions
      const safeContent = finalContent;
      
      // IMPORTANT: Ensure the streaming message display shows the complete content
      // This fixes cases where the streaming display might show a truncated message
      setStreamingMessage(safeContent);
      
      // Add a final synthetic thinking step if needed
      const finalStep = {
        type: 'thinking',
        description: 'Response completed',
        time: new Date().toTimeString().split(' ')[0],
        duration_ms: 0
      };
      
      setThinkingSteps(prev => {
        // Check for duplicate
        const isDuplicate = prev.some(step => step.description === finalStep.description);
        if (!isDuplicate) {
          return [...prev, finalStep];
        }
        return prev;
      });
      
      // Create the assistant message with the COMPLETE content
      const assistantMessage: ChatMessage = {
        role: 'assistant',
        content: safeContent,
        timestamp: new Date(),
        thinkingSteps: [...thinkingSteps],
      };
      
      // Add message to chat history
      console.log('Adding message to chat history with content length:', safeContent.length);
      
      // CRITICAL: We need to add a small delay before adding to history to ensure
      // the streaming display has had time to update with the complete content
      setTimeout(() => {
        // First add the message to the chat history
        setMessages(prevMessages => {
          const updatedMessages = [...prevMessages, assistantMessage];
          
          // Save the conversation to the database in the background
          if (data.conversation_id) {
            saveConversationToDatabase(data.conversation_id, updatedMessages)
              .catch(err => console.error('Failed to save conversation:', err));
          }
          
          return updatedMessages;
        });
        
        // Scroll to the end to show the complete message
        if (messagesEndRef.current) {
          messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
        }
        
        // Then clear the streaming message state after a much longer delay 
        // to ensure the full message has been displayed and the message history is updated
        setTimeout(() => {
          console.log('Timeout executed - checking if safe to clear streaming state');
          
          // Check if we actually added the message to chat history before clearing
          setMessages(currentMessages => {
            const lastMessage = currentMessages[currentMessages.length - 1];
            
            // Only clear streaming if the message was added to history successfully
            // AND the content matches what we expect
            if (lastMessage && 
                lastMessage.role === 'assistant' && 
                lastMessage.content === safeContent) {
              console.log('Message found in history, safe to clear streaming state');
              setStreamingMessage('');
              setStreamingId(null);
              setThinkingSteps([]);
              setIsLoading(false);
              setIsThinking(false); // Finally clear the thinking state
            } else {
              // Something went wrong, don't clear yet
              console.warn('Last message in history does not match final content or is missing, NOT clearing streaming state');
              if (lastMessage) {
                console.warn('Last message content length:', lastMessage.content.length);
                console.warn('Safe content length:', safeContent.length);
                // If the message is there but content doesn't match, it might have been truncated
                if (lastMessage.role === 'assistant' && lastMessage.content !== safeContent) {
                  console.warn('Fixing truncated message in history');
                  // Fix the truncated message in history
                  const fixedMessages = [...currentMessages];
                  fixedMessages[fixedMessages.length - 1] = {
                    ...lastMessage,
                    content: safeContent
                  };
                  return fixedMessages;
                }
              }
            }
            
            return currentMessages;
          });
        }, 2000); // Much longer delay (2 seconds) to ensure content is displayed
      }, 100); // Short delay to ensure streaming display has updated
      
    } catch (err) {
      console.error('Error parsing done event', err);
      setIsLoading(false);
      setIsThinking(false);
    }
  };

  // Function to save the conversation to the database
  const saveConversationToDatabase = async (conversationId: string, messageList: ChatMessage[]) => {
    if (!session?.user) return;
    
    const currentHash = generateMessageHash(messageList);
    
    // Skip saving if this exact message set was already saved
    if (currentHash === lastSavedHash) {
      console.log('Skipping save - messages already saved');
      return;
    }
    
    try {
      const response = await fetch('/api/chat/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          conversation_id: conversationId,
          title: messageList.length > 0 ? messageList[0].content.substring(0, 50) : 'New Chat',
          messages: messageList,
          context_summary: contextSummary // Include the context summary
        }),
      });

      if (response.ok) {
        setLastSavedHash(currentHash);
        console.log('Conversation saved successfully');
      } else {
        console.error('Failed to save conversation');
      }
    } catch (error) {
      console.error('Error saving conversation:', error);
    }
  };

  const handleError = (e: MessageEvent) => {
    // Simple logging without trying to access detailed properties
    console.log('Stream error event received');
    
    setIsLoading(false);
    
    // Close the event source
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
  };

  // Non-streaming fallback
  const sendMessageWithoutStreaming = async (query: string) => {
    try {
      const chatRequest: ChatRequest = {
        query,
        conversation_id: conversationId,
        stream: false
      };
      
      const response = await chatApi.query(chatRequest);
      
      // Update conversation ID
      if (response.conversation_id) {
        setConversationId(response.conversation_id);
        
        // Notify parent about new session if needed
        if (!sessionId && onNewSession) {
          onNewSession(response.conversation_id);
        }
      }
      
      // Add assistant message
      const assistantMessage: ChatMessage = {
        role: 'assistant',
        content: response.response || '',  // Use response property instead of answer
        timestamp: new Date(),
        thinkingSteps: [], // No thinking steps in non-streaming response
        documents: [] // No documents in non-streaming response
      };
      
      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Error sending message:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Add a function to copy message content to clipboard
  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text)
      .then(() => {
        console.log('Text copied to clipboard');
      })
      .catch(err => {
        console.error('Failed to copy text: ', err);
      });
  };

  // Add a function to toggle search mode
  const toggleSearchMode = (e: React.MouseEvent) => {
    e.preventDefault();
    setIsSearchMode(!isSearchMode);
  };

  // Function to start a new chat
  const startNewChat = async () => {
    setIsSaving(true);
    try {
      // Save the old conversation before starting a new one
      if (conversationId && messages.length > 0) {
        await saveConversationToDatabase(conversationId, messages);
        console.log('Saved conversation before starting new chat');
      } else {
        console.log('No messages to save before starting new chat');
      }
    } catch (error) {
      console.error('Error saving session before new chat:', error);
    } finally {
      setIsSaving(false);
    }
    
    // Clear current conversation state and reset hash tracking
    setMessages([]);
    setConversationId(undefined);
    setInput('');
    setStreamingMessage('');
    setStreamingId(null);
    setThinkingSteps([]);
    setLastSavedHash(''); // Reset the hash for the new conversation
    accumulatedContentRef.current = '';
    
    // Reset search mode
    setIsSearchMode(false);
    
    // If there's a handler to notify the parent component
    if (onNewSession) {
      onNewSession('new'); // Signal to parent that we want a new chat
    }
  };

  return (
    <div className="flex flex-col h-full w-full overflow-hidden">
      <div ref={chatContainerRef} className="flex-1 overflow-y-auto p-4 space-y-6 relative bg-gray-50 w-full">
        {/* Debug output */}
        {process.env.NODE_ENV === 'development' && (
          <div className="text-xs text-gray-400 mb-2">
            Accumulated content length: {accumulatedContentRef.current.length}
          </div>
        )}
        
        {/* Welcome message when no messages exist */}
        {messages.length === 0 && !streamingMessage && (
          <div className="flex items-center justify-center h-full">
            <div className="text-center max-w-md mx-auto p-8 rounded-xl bg-white shadow-lg border border-gray-100 bg-gradient-to-b from-white to-gray-50">
              <div className="mb-6 bg-gradient-to-br from-indigo-500 to-purple-600 text-white w-20 h-20 rounded-full flex items-center justify-center mx-auto shadow-md">
                <span className="text-3xl font-bold" style={{ textShadow: '0px 2px 3px rgba(0, 0, 0, 0.3)' }}>K</span>
              </div>
              <h3 className="text-2xl font-semibold text-gray-800 mb-3">Welcome to Kevin.AI</h3>
              <p className="text-gray-600 mb-8 leading-relaxed">Let Kevin.AI assist you with Canadian university information...</p>
              <div className="flex flex-col sm:flex-row justify-center gap-3">
                <button 
                  onClick={() => setInput("What are the admission requirements for UBC Computer Science?")}
                  className="px-4 py-3 bg-gray-100 hover:bg-gray-200 rounded-xl text-sm text-gray-700 transition-colors font-medium shadow-sm hover:shadow"
                >
                  UBC Computer Science requirements
                </button>
                <button 
                  onClick={() => setInput("Compare tuition costs between University of Toronto and McGill for international students")}
                  className="px-4 py-3 bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 rounded-xl text-sm text-white transition-colors font-medium shadow-sm hover:shadow"
                >
                  UofT vs McGill tuition costs
                </button>
              </div>
            </div>
          </div>
        )}
        
        {/* Show date separator for messages */}
        {messages.length > 0 && (
          <div className="flex justify-center">
            <span className="text-xs text-gray-600 bg-white px-3 py-1.5 rounded-full shadow-md border border-gray-100 font-medium">
              {new Date(messages[0].timestamp).toLocaleDateString(undefined, {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
              })}
            </span>
          </div>
        )}
        
        {/* Show all message exchanges instead of just the most recent one */}
        {messageExchanges.map((exchange, exchangeIndex) => (
          <div key={`exchange-${exchangeIndex}`} className="space-y-6 mb-6">
            {exchange.map((message, messageIndex) => (
              <div 
                key={`message-${exchangeIndex}-${messageIndex}-${message.timestamp.getTime()}`} 
                className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
              >
                {/* Role indicator for assistant */}
                {message.role === 'assistant' && (
                  <div className="w-8 h-8 rounded-full bg-gradient-to-br from-teal-500 to-emerald-600 text-white flex items-center justify-center mr-2 flex-shrink-0 mt-1 shadow-md">
                    <span className="text-lg font-bold" style={{ textShadow: '0px 1px 2px rgba(0, 0, 0, 0.2)' }}>K</span>
                  </div>
                )}
                
                <div 
                  className={`p-5 rounded-2xl max-w-[85%] md:max-w-[75%] relative group ${
                    message.role === 'user' 
                      ? 'bg-gradient-to-br from-indigo-600 to-purple-700 text-white shadow-lg'
                      : 'bg-white text-gray-800 border border-gray-100 shadow-md hover:shadow-lg transition-shadow'
                  }`}
                >
                  {/* Copy button - only visible on hover */}
                  <button
                    onClick={() => copyToClipboard(message.content)}
                    className={`absolute top-3 right-3 p-1.5 rounded-full opacity-0 group-hover:opacity-100 transition-opacity text-xs ${
                      message.role === 'user' 
                        ? 'bg-indigo-400/50 hover:bg-indigo-400 text-white backdrop-blur-sm' 
                        : 'bg-gray-100 hover:bg-gray-200 text-gray-600'
                    }`}
                    title="Copy message"
                    aria-label="Copy message"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                    </svg>
                  </button>
                  
                  <div className={`whitespace-pre-wrap markdown-content text-base leading-relaxed ${
                    message.role === 'user' 
                      ? 'text-white !important font-medium' 
                      : 'text-gray-700'
                  }`}
                  style={message.role === 'user' 
                    ? { 
                        color: 'white', 
                        textShadow: '0px 1px 2px rgba(0, 0, 0, 0.25)'
                      } 
                    : undefined
                  }
                  >
                    {message.role === 'assistant' ? (
                      <ReactMarkdown remarkPlugins={[remarkGfm]}>
                        {message.content}
                      </ReactMarkdown>
                    ) : (
                      message.content
                    )}
                  </div>

                  {/* Message timestamp */}
                  <div className={`text-xs mt-3 flex items-center ${
                    message.role === 'user' 
                      ? 'text-indigo-100/75' 
                      : 'text-gray-400'
                  }`}>
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    {message.timestamp.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}
                  </div>
                </div>
                
                {/* Role indicator for user */}
                {message.role === 'user' && (
                  <div className="w-8 h-8 rounded-full bg-gradient-to-br from-indigo-500 to-purple-600 text-white flex items-center justify-center ml-2 flex-shrink-0 mt-1 shadow-md">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                    </svg>
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
        
        {/* Simple loading indicator when waiting for response */}
        {isLoading && !streamingMessage && (
          <div className="flex justify-center my-6">
            <div className="flex items-center space-x-2 bg-white px-5 py-3 rounded-full shadow-md border border-gray-100">
              <div className="animate-pulse flex items-center">
                <div className="h-2.5 w-2.5 mr-1 bg-indigo-500 rounded-full"></div>
                <div className="h-2.5 w-2.5 mr-1 bg-indigo-500 rounded-full animation-delay-200"></div>
                <div className="h-2.5 w-2.5 bg-indigo-500 rounded-full animation-delay-500"></div>
              </div>
              <span className="text-sm text-gray-600 font-medium">Kevin is thinking...</span>
            </div>
          </div>
        )}
        
        {/* Streaming message (currently being received) */}
        {streamingMessage && (
          <div className="flex mb-4 mt-4">
            {/* Assistant icon */}
            <div className="w-8 h-8 rounded-full bg-gradient-to-br from-purple-500 to-indigo-600 text-white flex items-center justify-center mr-2 flex-shrink-0 mt-1 shadow-md">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" />
              </svg>
            </div>
            
            <div className="p-4 rounded-lg shadow-md border border-gray-100 bg-white/95 relative flex-1 max-w-4xl">
              {/* Key UI improvement: Ensure the content doesn't get cut off */}
              <div className="markdown prose prose-blue max-w-none">
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {streamingMessage}
                </ReactMarkdown>
                
                {/* Typing indicator */}
                <div className="flex items-center mt-2">
                  <div className="typing-indicator">
                    <span></span>
                    <span></span>
                    <span></span>
                  </div>
                </div>
              </div>
              
              {/* State for debugging */}
              {process.env.NODE_ENV === 'development' && (
                <div className="text-xs text-gray-400 mt-2">
                  <div>Message length: {streamingMessage.length} chars</div>
                </div>
              )}
            </div>
          </div>
        )}
        
        {/* New Chat Button - Now at the bottom of the chat area */}
        {messages.length > 0 && (
          <div className="flex justify-center my-8 sticky bottom-4">
            <button
              onClick={startNewChat}
              disabled={isLoading || isSaving}
              className="flex items-center px-5 py-3 bg-gradient-to-r from-indigo-500 to-purple-600 border border-transparent rounded-full hover:shadow-lg transition-all text-white font-medium shadow-md disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
              </svg>
              {isSaving ? 'Saving conversation...' : 'Start New Chat'}
            </button>
          </div>
        )}
        
        <div ref={messagesEndRef} />
      </div>
      
      {/* Input form - Updated for a more modern look */}
      <div className="bg-gray-50 p-4 border-t border-gray-100">
        <div className="max-w-4xl mx-auto relative">
          <form onSubmit={handleSubmit} className="flex space-x-3">
            <div className="relative flex-1 flex items-start">
              {/* Styled textarea for multi-line support */}
              <textarea
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (input.trim() && !isLoading) {
                      handleSubmit(e);
                    }
                  }
                }}
                placeholder={isSearchMode ? "Search the web..." : "Ask me anything..."}
                rows={1}
                style={{ 
                  minHeight: '56px', 
                  maxHeight: '200px',
                  resize: 'none', 
                  height: 'auto',
                  paddingRight: '3rem' 
                }}
                onInput={(e) => {
                  const target = e.target as HTMLTextAreaElement;
                  target.style.height = 'auto';
                  target.style.height = `${Math.min(target.scrollHeight, 200)}px`;
                }}
                className={`w-full p-4 pr-12 border rounded-xl shadow-md ${
                  isSearchMode 
                    ? "bg-blue-50 border-blue-200 focus:bg-blue-50/80" 
                    : "bg-white border-gray-200 focus:bg-white"
                } focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none transition-all text-gray-700`}
                disabled={isLoading}
              />
              
              {/* Search toggle button with improved styling */}
              <div className="absolute right-3 top-3">
                <button
                  onClick={toggleSearchMode}
                  type="button"
                  className={`p-2 rounded-full transition-all ${
                    isSearchMode 
                      ? "text-white bg-indigo-500 shadow-md" 
                      : "text-gray-500 bg-gray-100 hover:bg-gray-200 hover:text-gray-700"
                  }`}
                  title={isSearchMode ? "Back to chat mode" : "Switch to search mode"}
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                  </svg>
                </button>
              </div>
            </div>
            <button
              type="submit"
              disabled={isLoading || !input.trim()}
              className={`p-4 rounded-xl w-14 h-auto flex-shrink-0 flex items-center justify-center transition-all ${
                isLoading 
                  ? "bg-gray-300 text-gray-500 cursor-not-allowed" 
                  : isSearchMode 
                    ? "bg-gradient-to-r from-indigo-500 to-purple-600 text-white hover:shadow-md shadow-sm hover:from-indigo-600 hover:to-purple-700" 
                    : "bg-gradient-to-r from-indigo-500 to-purple-600 text-white hover:shadow-md shadow-sm hover:from-indigo-600 hover:to-purple-700"
              }`}
              style={{ alignSelf: 'flex-start' }}
            >
              {isLoading ? (
                <span className="animate-pulse">...</span>
              ) : isSearchMode ? (
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
              ) : (
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 5l7 7-7 7M5 5l7 7-7 7" />
                </svg>
              )}
            </button>
          </form>
          
          <div className="text-xs text-gray-500 mt-3 text-center">
            AI responses may not always be accurate. Verify important information.
          </div>
        </div>
      </div>
    </div>
  );
} 